<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CodePoints.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">junit-quickcheck-generators</a> &gt; <a href="index.source.html" class="el_package">com.pholser.junit.quickcheck.generator.java.lang.strings</a> &gt; <span class="el_source">CodePoints.java</span></div><h1>CodePoints.java</h1><pre class="source lang-java linenums">/*
 The MIT License

 Copyright (c) 2010-2020 Paul R. Holser, Jr.

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 &quot;Software&quot;), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

package com.pholser.junit.quickcheck.generator.java.lang.strings;

import static java.lang.String.format;

import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Maps ordinal values to corresponding Unicode code points in a
 * {@link java.nio.charset.Charset}.
 */
public class CodePoints {
<span class="fc" id="L42">    private static final Map&lt;Charset, CodePoints&gt; ENCODABLES =</span>
        new HashMap&lt;&gt;();

    private final List&lt;CodePointRange&gt; ranges;

<span class="fc" id="L47">    CodePoints() {</span>
<span class="fc" id="L48">        ranges = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L49">    }</span>

    /**
     * @param index index to look up
     * @return this code point set's {@code index}'th code point
     * @throws IndexOutOfBoundsException if there is no such code point
     */
    public int at(int index) {
<span class="fc bfc" id="L57" title="All 2 branches covered.">        if (index &lt; 0) {</span>
<span class="fc" id="L58">            throw new IndexOutOfBoundsException(</span>
                &quot;illegal negative index: &quot; + index);
        }

<span class="fc" id="L62">        int min = 0;</span>
<span class="fc" id="L63">        int max = ranges.size() - 1;</span>

<span class="fc bfc" id="L65" title="All 2 branches covered.">        while (min &lt;= max) {</span>
<span class="fc" id="L66">            int midpoint = min + ((max - min) / 2);</span>
<span class="fc" id="L67">            CodePointRange current = ranges.get(midpoint);</span>

<span class="fc bfc" id="L69" title="All 2 branches covered.">            if (index &gt;= current.previousCount</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">                &amp;&amp; index &lt; current.previousCount + current.size()) {</span>

<span class="fc" id="L72">                return current.low + index - current.previousCount;</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">            } else if (index &lt; current.previousCount) {</span>
<span class="fc" id="L74">                max = midpoint - 1;</span>
            } else {
<span class="fc" id="L76">                min = midpoint + 1;</span>
            }
<span class="fc" id="L78">        }</span>

<span class="fc" id="L80">        throw new IndexOutOfBoundsException(String.valueOf(index));</span>
    }

    /**
     * @return how many code points are in this code point set
     */
    public int size() {
<span class="fc bfc" id="L87" title="All 2 branches covered.">        if (ranges.isEmpty())</span>
<span class="fc" id="L88">            return 0;</span>

<span class="fc" id="L90">        CodePointRange last = ranges.get(ranges.size() - 1);</span>
<span class="fc" id="L91">        return last.previousCount + last.size();</span>
    }

    /**
     * @param codePoint a code point
     * @return whether this code point set contains the given code point
     */
    public boolean contains(int codePoint) {
<span class="fc" id="L99">        return ranges.stream().anyMatch(r -&gt; r.contains(codePoint));</span>
    }

    /**
     * Gives a set of the code points in the given charset.
     *
     * @param c a charset
     * @return the set of code points in the charset
     */
    public static CodePoints forCharset(Charset c) {
<span class="fc bfc" id="L109" title="All 2 branches covered.">        if (ENCODABLES.containsKey(c))</span>
<span class="fc" id="L110">            return ENCODABLES.get(c);</span>

<span class="fc" id="L112">        CodePoints points = load(c);</span>
<span class="fc" id="L113">        ENCODABLES.put(c, points);</span>
<span class="fc" id="L114">        return points;</span>
    }

    private static CodePoints load(Charset c) {
<span class="fc bfc" id="L118" title="All 2 branches covered.">        if (!c.canEncode()) {</span>
<span class="fc" id="L119">            throw new IllegalArgumentException(</span>
<span class="fc" id="L120">                &quot;Charset &quot; + c.name() + &quot; does not support encoding&quot;);</span>
        }

<span class="fc" id="L123">        return encodableCodePoints(c.newEncoder());</span>
    }

    void add(CodePointRange range) {
<span class="fc" id="L127">        ranges.add(range);</span>
<span class="fc" id="L128">    }</span>

    private static CodePoints encodableCodePoints(CharsetEncoder encoder) {
<span class="fc" id="L131">        CodePoints points = new CodePoints();</span>

<span class="fc" id="L133">        int start = 0;</span>
<span class="fc" id="L134">        boolean inRange = false;</span>
<span class="fc" id="L135">        int current = 0;</span>
<span class="fc" id="L136">        int previousCount = 0;</span>
<span class="fc" id="L137">        int[] buffer = new int[1];</span>

<span class="fc bfc" id="L139" title="All 2 branches covered.">        for (; current &lt;= Character.MAX_CODE_POINT; ++current) {</span>
<span class="fc" id="L140">            encoder.reset();</span>
<span class="fc" id="L141">            buffer[0] = current;</span>

<span class="fc" id="L143">            String s = new String(buffer, 0, 1);</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">            if (encoder.canEncode(s)) {</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">                if (!inRange) {</span>
<span class="fc" id="L146">                    inRange = true;</span>
<span class="fc" id="L147">                    start = current;</span>
                }
<span class="fc bfc" id="L149" title="All 2 branches covered.">            } else if (inRange) {</span>
<span class="fc" id="L150">                inRange = false;</span>
<span class="fc" id="L151">                CodePointRange range =</span>
                    new CodePointRange(start, current - 1, previousCount);
<span class="fc" id="L153">                points.add(range);</span>
<span class="fc" id="L154">                previousCount += range.size();</span>
            }
        }

<span class="fc bfc" id="L158" title="All 2 branches covered.">        if (inRange) {</span>
<span class="fc" id="L159">            points.add(</span>
                new CodePointRange(start, current - 1, previousCount));
        }

<span class="fc" id="L163">        return points;</span>
    }

    static class CodePointRange {
        final int low;
        final int high;
        final int previousCount;

<span class="fc" id="L171">        CodePointRange(int low, int high, int previousCount) {</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">            if (low &gt; high) {</span>
<span class="fc" id="L173">                throw new IllegalArgumentException(</span>
<span class="fc" id="L174">                    format(&quot;%d &gt; %d&quot;, low, high));</span>
            }

<span class="fc" id="L177">            this.low = low;</span>
<span class="fc" id="L178">            this.high = high;</span>
<span class="fc" id="L179">            this.previousCount = previousCount;</span>
<span class="fc" id="L180">        }</span>

        boolean contains(int codePoint) {
<span class="fc bfc" id="L183" title="All 4 branches covered.">            return codePoint &gt;= low &amp;&amp; codePoint &lt;= high;</span>
        }

        int size() {
<span class="fc" id="L187">            return high - low + 1;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>